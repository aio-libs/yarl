from typing import overload, Any, Tuple, Optional, Mapping, Union, Sequence
import multidict


class URL:
    scheme: str = ...
    raw_user: str = ...
    user: Optional[str] = ...
    raw_password: Optional[str] = ...
    password: Optional[str] = ...
    raw_host: Optional[str] = ...
    host: Optional[str] = ...
    port: Optional[int] = ...
    raw_path: str = ...
    path: str = ...
    raw_query_string: str = ...
    query_string: str = ...
    path_qs: str = ...
    raw_path_qs: str = ...
    raw_fragment: str = ...
    fragment: str = ...
    query: multidict.MultiDict = ...
    raw_name: str = ...
    name: str = ...
    raw_parts: Tuple[str, ...] = ...
    parts: Tuple[str, ...] = ...
    parent: URL = ...

    def __init__(self, val: Union[str, 'URL']=..., *,
		 encoded: bool=...) -> None: ...

    @classmethod
    def build(cls, *, scheme: str=..., user: str=..., password: str=...,
	      host: str=..., port: int=..., path: str=...,
	      query: Mapping=..., query_string: str=...,
	      fragment: str=..., strict: bool=...) -> URL: ...

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    def __eq__(self, other: Any) -> bool: ...
    def __le__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

    def __truediv__(self, name: str) -> URL: ...

    def is_absolute(self) -> bool: ...
    def is_default_port(self) -> bool: ...

    def origin(self) -> URL: ...
    def relative(self) -> URL: ...

    def with_scheme(self, scheme: str) -> URL: ...
    def with_user(self, user: Optional[str]) -> URL: ...
    def with_password(self, password: Optional[str]) -> URL: ...
    def with_host(self, host: str) -> URL: ...
    def with_port(self, port: Optional[int]) -> URL: ...
    def with_path(self, path: str, *, encoded: bool=...) -> URL: ...

    @overload
    def with_query(self, query: str) -> URL: ...
    @overload
    def with_query(self, query: Mapping[str, Union[str, int]]) -> URL: ...
    @overload
    def with_query(self, query: Sequence[Tuple[str, Union[str, int]]]) -> URL: ...
    @overload
    def with_query(self, **kwargs: Union[str, int]) -> URL: ...

    @overload
    def update_query(self, query: str) -> URL: ...
    @overload
    def update_query(self, query: Mapping[str, Union[str, int]]) -> URL: ...
    @overload
    def update_query(self, query: Sequence[Tuple[str, Union[str, int]]]) -> URL: ...
    @overload
    def update_query(self, **kwargs: Union[str, int]) -> URL: ...

    def with_fragment(self, fragment: Optional[str]) -> URL: ...
    def with_name(self, name: str) -> URL: ...

    def join(self, url: URL) -> URL: ...

    def human_repr(self) -> str: ...

    # private API

    @classmethod
    def _normalize_path(cls, path: str) -> str: ...


class cached_property:
    def __init__(self, wrapped: Any) -> None: ...

    def __get__(self, inst: cached_property, owner) -> Any: ...

    def __set__(self, inst: cached_property, value) -> None: ...
